---
tags:
  - university-notes
university-name: Virtual University of Pakistan
date: 2025-09-08
---

# 02. `Interrupt`[^1] Mechanism

<span style="color: gray;">Dated: 08-09-2025</span>

> [!NOTE] For an `interrupt`[^1] invocation, the following `registers` are pushed.
> 1. `IP`
> 2. `CS`
> 3. `FLAGS`

## The `Interrupt`[^1] Vector Table

> [!NOTE] Each entry in the table contains a `far address` of an `interrupt handler` hence there is a maximum of $256$ `handlers` however each `handler` can have a number of `services` within itself.

![[cs609_e_2_1.svg]]  
/// caption  
`Interrupt Vector Table`  
///

The `IVT` resides in `0000:0000H` pair (`segment:offset` pair). Each entry contains a `far address` which consists of first `2 bytes` (lower word) for `offset` and `2 bytes` (higher word) for `segment address`.

$$\text{Interrupt Vector} = \text{Segment Address} : \text{Interrupt Index} \times 4$$

> [!EXAMPLE]- Computing vector of `INT21H`  
> $\text{Interrupt Vector} = 0000 : 0021H \times 4 = 0000 : 0084H$

## Location of `ISRs` (`Interrupt Service routines`)

There are 3 kinds of `ISRs` depending upon the entity implementing them.

1. `BIOS` (Basic I/O services) `ISRs`
2. `DOS ISRs`
3. `ISRs` provided by third party `device drivers`


- `ROM BIOS` address starts from `F000:0000H`.
- `Interrupts`[^1] provided by `DOS` are in `io.sys` and `msdos.sys` and provided by `windows` are in `kernel32.dll` and `kernel.dll`
- The `interrupts`[^1] provided by `device drivers` reside in the memory occupied by those `drivers`.

## `Interrupt`[^1] Invocation

After an `interrupt`[^1] has been invoked, the `CPU` takes a certain series of steps.

- Push `Flags`, `CS`, `IP Registers`, `Clear Interrupt Flag`.
- Use $\text{Interrupt Index} \times 4$ and $0$ for `segment` value.
- This value is `interrupt vector` and not the `ISR` itself.
- Use lower `word` as `offset` and move into `IP`
- Use higher `word` as `segment address` and move into `CS = 0:[offset + 2]`
- Branch to `ISR` and perform the `I/O` operation.
- Return to the point of `interrupt` by popping `6 bytes` (of `FLAGS`, `CS`, `IP`).

## Parameter Passing into Software `Interrupts`[^1]

The parameters are passed through `registers`.

## Software `Interrupts`[^1] Invocation

### Example

`Interrupt`:[^1] `21H`  
Service: `09H`

It is used to print a `string` ending by a `$` symbol.

#### Inputs

- `AH` = `#!c 0x09`
- `DS` = `Segment Address` of the `string`
- `DX` = `Offset Address` of the `string`

#### Output

String ending with `$`.

> [!NOTE] Following code example works with a `16-bit DOS` compiler.

```cpp
#include <stdio.h>
#include <BIOS.h>
#include <DOS.h>
#include <conio.h>

char st[80] = {"Hello World$"};

void main () {
	clrsrc(); //to clear the screen contents
	_DX = (unsigned int) st; // pseudo variable
	_AH = 0x09;              // pseudo variable
	geninterrupt(0x21);
	getch(); //waits for the user to press any key
}
```

## The `int86()` `function`

```cpp
struct full {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
};

struct half {
    unsigned char al;
    unsigned char bl;
    unsigned char cl;
    unsigned char dl;
    unsigned char ah;
    unsigned char bh;
    unsigned char ch;
    unsigned char dh;
};

typedef union tarREG {
    struct full x;
    struct full h;
} REGS;
```

The `int86()` has 3 parameters.

1. `Interrupt`[^1] number
2. Reference to `REGS` `#!c union`[^2] containing the parameter values.
3. Reference to `REGS` `#!c union`[^2] which will contain the `register` values which are to be expected as the result of `interrupt`.[^1]

> [!QUESTION]- Potential MCQs  
> These MCQs are in the original text but not on this website
> 
> 1. `Return Adress` is the value of `IP register` in case of _near procedure_ and value of `CS` and `IP register` in case of _far procedure_.

## References

[^1]: Read more about [[cs604_02|interrupts]].
[^2]: Read more about [[C_union|unions]].