---
tags:
  - university-notes
university-name: Virtual University of Pakistan
date: 2025-03-14
---

# Lecture No. 2

<span style="color: gray;">Dated: 14-03-2025</span>

## Single User Systems

These systems are designed to provide most convenience to a single user instead of focusing over maximizing utility of the CPU and other peripheral devices.

## Batch Systems

Early computers were controlled by consoles with card readers. These computers would output data on punch cards and also take in punch cards as inputs, which describe the "job" which needs to be performed. These inputs were handed over to computer operators who would feed it to the computer but due to slow mechanical I/O movements, a lot of CPU time was wasted.  
In these systems, users would not be able to interact with their jobs and jobs with similar needs were executed in a "batch".

### Example

`Digital Equipment Corporation`â€™s `VMS` is an example of a batch operating system.

![[cs604_e_2_1.svg]]  
/// caption  
Memory partitioned into `user` and `system spaces`  
///

## Multi Programmed Systems

There's a `job pool` which contains all the jobs ready to be executed but only a fraction of those can be loaded in the memory, at the same time.  
The `operating system`[^1] arranges them so that CPU executes one `job` at a time.  
This `job` might require an `I/O` operation and instead of waiting, CPU switches to the other `job` execution.

![[cs604_e_2_2.svg]]  
/// caption  
Memory layout for a `multi-programmed batch system`  
///

Imagine two `processes` $P_1$ and $P_2$.  
$P_1$ completes its `CPU burst` (unit of time), starts to wait for an event (maybe an `I/O` operation) to happen and in the meantime, the `CPU` switches to $P_2$ and vise versa happens.

![[cs604_i_2_3.png]]  
/// caption  
Illustration of the multiprogramming concept. Both processes take `6` units instead of `10` to be completed.  
///

### Job Pool

The processes which are in the disk and are waiting for memory allocation for the sake of execution, are placed in `job pool`.  

#### Job Scheduling

The system decides which `job` to bring in memory if there are competing `jobs`, through a process called `job scheduling`.

## Time Sharing Systems

Such system is multi-user, multi-process, and interactive, allowing multiple users to run and interact with their multiple jobs at the same time on the computer.  
This uses [Multi programming](#multi-programmed-systems) and `CPU scheduling`.

### Example

- `UNIX`
- `Linux`
- `Windows NT`
- `Windows 2000`

## Real time Systems

These systems have very tight time constraints and if are failed to be delivered, the system fails.

### Example

- Scientific experiments
- Medical imaging
- Industrial control systems
- Display systems

### Types

There are 2 types

#### Hard

These are very time critical and lean less on operating systems and data retrieval from disk etc.

#### Soft

In these systems, the time critical tasks take the priority and retain that priority until it is finished.  
These systems can be mixed with other types of systems unlike [hard real time systems](#hard) because those conflict with `operating system kernels` of other systems such as [time sharing systems](#time-sharing-systems) and hence cannot be mixed.

## Interrupts

It is a `signal` generated by a `hardware device` such as an `I/O device` to get `CPU`'s attention.  
These `signals` transfer the control to `Interrupt Service Routine`(`ISR`) generally through the `interrupt vector table` which contains the addresses of all the `service routines`.  
The address of the interrupted instruction is saved, which is later used to come back to that instruction after the `interrupt` has been addressed.  
During `interrupt processing`, incoming `interrupts` are disabled to prevent `lost interrupts`.  
An `operating system`[^1] is an `interrupt` driven software.

## Trap

It is also called an `exception` which is generated by the software as a result of an error such as `division by zero` or rejection to a user request from the `operating system`[^1] service.

## Signal

A `signal` is generated to get attention of a process.

### Example

When you press `Ctrl + C` while a `process` is running, it sends an [interrupt](#interrupt) `signal` (`SIGINT`).

### Possible Actions

- `Kernel` defined default action which usually terminates the `process` but sometimes can also generate a `core` file which allows the user to know the state of the `process` at termination.
- Program can intercept the `signal` and ignore it.
- Program can intercept the `signal` and perform a programmer defined action.

## Hardware Protection

[Multiprogramming](#multi-programmed-systems) improves `system utilization` by running multiple programs in `memory`, but it introduces risks like faulty programs affecting others, overwriting `data`, or monopolizing the `CPU`.  
This leads to key hardware protection issues

- `I/O`
- `memory`
- `CPU protection`

### Dual Mode Operation

To protect the `OS`[^1] and `programs` from faulty `processes`, shared resources require protection. Modern CPUs support this via `privileged and non-privileged instructions`. `Privileged instructions` (e.g., I/O operations) are restricted to the `OS`.[^1] If a `user process` executes them, a [trap](#trap) is triggered and the `process` is terminated.

To enforce this, CPUs operate in two modes: `user mode` and `monitor` (or `system/supervisor) mode`, distinguished by a `mode bit` (0 = monitor, 1 = user). This allows the `CPU` to identify whether code is `OS`[^1] or `user-level`.

`System calls` let user processes safely request `OS-level` actions. When a `system call`, [interrupt](#interrupt), or [trap](#trap) occurs, the `CPU` switches to `monitor mode` to run `kernel code`, then switches back to `user mode` when returning control.

![[cs604_e_2_4.svg]]  
/// caption  
The `dual-mode` operation of the `CPU`  
///

### I/O Protection

To prevent `user processes` from disrupting the `system`, mechanisms are needed to block illegal `I/O`, `memory access`, and `CPU` misuse.

All `I/O instructions` are privileged, so `user processes` must access `I/O` via `system calls`. To ensure full `I/O protection`, `user programs` must never gain `monitor mode` control.

During execution, the `CPU` switches to `monitor mode` on [traps](#trap) or [interrupts](#interrupts) and jumps to `addresses` in the `interrupt vector`. If a `user process` could modify this `vector`, it could redirect control to itself in `monitor mode`, compromising security. Therefore, `I/O` and system memory modifications must be restricted to `monitor mode` only.

## References

[^1]: Read more about [[cs604_01|operating systems]].