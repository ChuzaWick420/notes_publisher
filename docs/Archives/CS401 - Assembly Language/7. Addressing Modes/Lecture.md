---
tags:
  - university-notes
university-name: Virtual University of Pakistan
---

# Register + Offset Addressing

```asm
[org 0x0100]
	mov	bx,0	; initialize array index to zero
	mov	cx,10	; load count of numbers in cx
	mov	ax,0	; initialize sum to zero

l1:	add	ax,[num1+bx]	; add number to ax
	add	bx,2	; advance bx to next index
	sub	cx,1	; numbers to be added reduced
	jnz	l1	; if numbers remain add next

	mov	[total],ax	; write back sum in memory

	mov	ax,0x4c00	; terminate program
	int	0x21

num1:	dw	10,20,30,40,50,10,20,30,40,50
total:	dw	0

```

In this example, we are using the `bx` as an `index` of an `array`.  
We use `num1` as our reference, then we refer to `bx`, increment by `2` and the loop repeats itself .

# Segment Association
All the addressing mechanisms in `iapx88` returns a number called `effective address`.  
The physical address which we get after addition of `base` and `offset` is an example of `effective address`.  
But this address alone is useless without a defined segment.

Without the `segment`, the `offset` is meaningless.  
There are default associations between `segments` and #register. Such as:  
#instruction-pointer is associated with `code segment` and cannot be used outside of it.  
Similarly, the #stack-pointer is associated with `stack segment`.

However, when it comes to data, if we use `DI`, `SI`, `BX` then the associated segment is `data segment` by default.  
If we use `BP` then the associated segment will be `stack segment`.

To override the associations of one of these #register i.e. `DI`, `SI`, `BX`, `BP`, we use `override prefix` such as `mov ax, [cs:bx]`.  
Here `CS` is associated with `BX`.

# Address Wraparound
There are 2 types of `wraparounds`.
1. Segment wraparound
2. Physical memory wraparound

## Segment Wraparound
Example: `BX = 9100` and `DS = 1500`, when the `effective address` is generated (`offset = 7000`), we get `9100 + 7000 = 10100`.  
Since `1` is a carry and is dropped, we are left with `0100`.

## Physical Memory Wraparound
Same thing happens here but we drop the carry after `20-bits` since `20` is the limit of addressing any memory location.

# Addressing Modes Summary
The memory access mechanisms can be written in general form as `base + index + offset`.  
Only addition is valid here, things like `base - index` are not allowed.  
Also, combination of `base + base` or `index + index` is also not allowed.

## Direct

```asm
mov [1234], ax
```

The value of `AX` is moved into address `1234`.

## Based Register Indirect

```asm
mov [bx], ax
```

Moves `AX` into the address stored by `BX` in the `data segment`.

## Indexed Register Indirect

```asm
mov [si], ax
```

The contents `AX` are moved into `SI` in the current data segment.

## Based Register Indirect + Offset

```asm
mov [bx + 300], ax
```

Here, the contents of `AX` are moved into the address we get by adding `bx + 300` in the `data segment`.

## Indexed Register Indirect + Offset
Same case here as well, just the #register are `index` type. i.e. `DI`, `SI`.

## Base + Index

```asm
mov [bx+si], ax
```

Just like before, contents of `AX` are moved into the resultant offset we get from `bx + si`.

## Base + Index + Offset
Same thing but with the combination of an `offset` value as well.

```asm
mov [bx+si+300], ax
```

# Exercises
1. What is a label and how does the assembler differentiates between code labels and data labels?
2. List the seven addressing modes available in the 8088 architecture.
3. Differentiate between effective address and physical address.
4. What is the effective address generated by the following instructions? Every instruction is independent of others. Initially `BX=0x0100`, `num1=0x1001`, `[num1]=0x0000`, and `SI=0x0100`
	1. `mov ax, [bx+12]`
	2. `mov ax, [bx+num1]`
	3. `mov ax, [num1+bx]`
	4. `mov ax, [bx+si]`
5. What is the effective address generated by the following combinations if they are valid. If not give reason. Initially `BX=0x0100`, `SI=0x0010`, `DI=0x0001`, `BP=0x0200`, and `SP=0xFFFF`.
	1. `bx-si`
	2. `bx-bp`
	3. `bx+10`
	4. `bx-10`
	5. `bx+sp`
	6. `bx+di`
6. Identify the problems in the following instructions and correct them by replacing them with one or two instruction having the same effect.
	1. `mov [02], [22]`
	2. `move [wordvar], 20`
	3. `mov bx, al`
	4. `mov ax, [si+di+100]`
7. What is the function of segment override prefix and what changes it brings to the opcode?
8. What are the two types of address wraparound? What physical address is accessed with `[BX+SI]` if `FFFF` is loaded in `BX`, `SI`, and `DS`.
9. Write instructions to do the following.
	1. Copy contents of memory location with offset 0025 in the current data segment into AX.
	2. Copy AX into memory location with offset 0FFF in the current data segment.
	3. Move contents of memory location with offset 0010 to memory location with offset 002F in the current data segment.
10. Write a program to calculate the square of 20 by using a loop that adds 20 to the accumulator 20 times.
